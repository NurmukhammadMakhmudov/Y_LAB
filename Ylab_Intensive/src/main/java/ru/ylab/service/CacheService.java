package main.java.ru.ylab.service;

import main.java.ru.ylab.model.Product;

import java.util.List;

/**
 * Сервис кэширования для ускорения повторных запросов.
 * <p>
 * Использует LRU (Least Recently Used) политику вытеснения и TTL (Time To Live) для управления
 * временем жизни записей. Предназначен для снижения нагрузки на хранилище и ускорения
 * доступа к часто запрашиваемым данным.
 * </p>
 * <p>
 * <strong>Ключевые особенности:</strong>
 * <ul>
 *   <li>Ограниченный размер кэша (максимум записей)</li>
 *   <li>Автоматическое удаление устаревших записей (TTL)</li>
 *   <li>LRU вытеснение — при переполнении удаляются давно не используемые записи</li>
 *   <li>Метрики попаданий/промахов для анализа эффективности</li>
 *   <li>Защитное копирование данных (defensive copy)</li>
 * </ul>
 * </p>
 * <p>
 * <strong>Потокобезопасность:</strong> сервис НЕ является потокобезопасным.
 * </p>
 * <p>
 * Пример использования:
 * <pre>{@code
 * CacheService cache = new CacheServiceImpl(5 * 60 * 1000, 100); // 5 минут, 100 записей
 *
 * List<Product> products = repository.findAll();
 * cache.put("all_products", products);  // Сохраняем в кэш
 *
 * // Позже
 * List<Product> cached = cache.get("all_products");  // Получаем копию из кэша
 *
 * // Анализируем эффективность
 * System.out.println("Hit ratio: " + cache.getHitRatio() * 100 + "%");
 * System.out.println("Avg time: " + cache.getAverageQueryTimeMs() + " ms");
 * }</pre>
 * </p>
 *
 * @see Product
 * @author Ваше Имя
 * @version 1.0
 * @since 2025-11-09
 */
public interface CacheService {

    /**
     * Возвращает максимальный размер кэша (максимальное количество записей).
     *
     * @return максимальное количество записей ({@code > 0})
     */
    int getMaxSize();

    /**
     * Возвращает время жизни записей в кэше в миллисекундах.
     * <p>
     * После этого времени запись считается устаревшей и удаляется при следующем обращении.
     * </p>
     *
     * @return TTL в миллисекундах ({@code > 0})
     */
    long getTtlMillis();

    /**
     * Получает значение из кэша по ключу.
     * <p>
     * <strong>Поведение:</strong>
     * <ul>
     *   <li>Если ключ найден и запись не устарела — возвращает защитную копию списка</li>
     *   <li>Если запись устарела — удаляет её и возвращает {@code null}</li>
     *   <li>Если ключа нет — возвращает {@code null}</li>
     *   <li>Увеличивает счётчик попаданий (hits) при успехе, промахов (misses) при неудаче</li>
     *   <li>Обновляет время последнего обращения для LRU</li>
     * </ul>
     * </p>
     *
     * @param key ключ для поиска (не может быть {@code null})
     * @return защитная копия списка товаров, если найдена и не устарела; {@code null} иначе
     * @throws NullPointerException если key равен {@code null}
     * @see #put(String, List)
     */
    List<Product> get(String key);

    /**
     * Сохраняет значение в кэш.
     * <p>
     * <strong>Поведение:</strong>
     * <ul>
     *   <li>Создаёт защитную копию списка перед сохранением</li>
     *   <li>Если кэш переполнен — удаляет LRU запись и добавляет новую</li>
     *   <li>Устанавливает текущее время как время добавления записи</li>
     * </ul>
     * </p>
     *
     * @param key ключ для сохранения (не может быть {@code null})
     * @param data список товаров для кэширования (не может быть {@code null})
     * @throws NullPointerException если key или data равны {@code null}
     * @see #get(String)
     * @see #invalidate(String)
     */
    void put(String key, List<Product> data);

    /**
     * Удаляет конкретную запись из кэша по ключу.
     * <p>
     * Используется при изменении данных в репозитории.
     * </p>
     *
     * @param key ключ записи для удаления (не может быть {@code null})
     * @throws NullPointerException если key равен {@code null}
     * @see #invalidateAll()
     */
    void invalidate(String key);

    /**
     * Очищает весь кэш.
     * <p>
     * Используется при значительных изменениях в репозитории (добавление, удаление, обновление товаров).
     * Сбрасывает счётчики метрик.
     * </p>
     *
     * @see #invalidate(String)
     */
    void invalidateAll();

    /**
     * Возвращает текущее количество записей в кэше.
     *
     * @return количество записей ({@code >= 0} и {@code <= getMaxSize()})
     */
    int size();

    /**
     * Возвращает количество попаданий в кэш (cache hits).
     * <p>
     * Попадание — это успешное получение данных из кэша.
     * </p>
     *
     * @return количество попаданий ({@code >= 0})
     * @see #getMisses()
     * @see #getHitRatio()
     */
    int getHits();

    /**
     * Возвращает количество промахов кэша (cache misses).
     * <p>
     * Промах — это неудачное получение данных (ключ не найден, запись устарела).
     * </p>
     *
     * @return количество промахов ({@code >= 0})
     * @see #getHits()
     * @see #getHitRatio()
     */
    int getMisses();

    /**
     * Возвращает коэффициент попаданий (hit ratio).
     * <p>
     * Вычисляется как: hits / (hits + misses).
     * Значение 1.0 = 100% попаданий (идеально),
     * значение 0.0 = 0% попаданий (все промахи).
     * </p>
     *
     * @return коэффициент попаданий (от 0.0 до 1.0, или 0.0 если нет запросов)
     * @see #getHits()
     * @see #getMisses()
     */
    double getHitRatio();

    /**
     * Возвращает среднее время выполнения одного запроса в миллисекундах.
     * <p>
     * Вычисляется как: общее время всех запросов / количество запросов.
     * Используется для анализа производительности кэша.
     * </p>
     *
     * @return среднее время в миллисекундах ({@code >= 0}, или 0.0 если нет запросов)
     */
    double getAverageQueryTimeMs();
}